{"task_id": "HumanEval/0", "solution": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False"}
{"task_id": "HumanEval/6", "solution": "def parse_nested_parens(paren_string: str) -> List[int]:\n    stack = []\n    depths = []\n\n    def parse_nested_parens_recursive(char):\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) > 0 and stack[-1] == '(':\n                stack.pop()\n            else:\n                depths.append(len(stack))\n\n    for char in paren_string:\n        parse_nested_parens_recursive(char)\n\n    return depths"}
{"task_id": "HumanEval/12", "solution": "def longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    max_length = max(len(s) for s in strings)\n    longest_string = max(strings, key=len)\n\n    return longest_string if max_length == len(longest_string) else None"}
{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n    return string.count(substring)"}
{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    # \u5982\u679cn\u4e3a0\uff0c\u76f4\u63a5\u8fd4\u56de0\n    if n == 0:\n        return 0\n\n    # \u5982\u679cn\u4e3a1\uff0c\u76f4\u63a5\u8fd4\u56de1\n    if n == 1:\n        return 1\n\n    # \u521d\u59cb\u5316\u6700\u5927\u7ea6\u6570\u4e3a1\n    max_divisor = 1\n\n    # \u904d\u5386\u4ece2\u5230n/2\u7684\u6574\u6570\n    for i in range(2, n // 2 + 1):\n        # \u5982\u679cn\u80fd\u88abi\u6574\u9664\uff0c\u4e14i\u5c0f\u4e8en\n        if n % i == 0:\n            # \u66f4\u65b0\u6700\u5927\u7ea6\u6570\n            max_divisor = max(max_divisor, i)\n\n    # \u8fd4\u56de\u6700\u5927\u7ea6\u6570\n    return max_divisor"}
{"task_id": "HumanEval/30", "solution": "def get_positive(l: list) -> list:\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    []\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    []\n    \"\"\"\n    return [num for num in l if num > 0]"}
{"task_id": "HumanEval/36", "solution": "\u8fd9\u4e2a\u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u6574\u6570n\u4f5c\u4e3a\u8f93\u5165\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u5c0f\u4e8en\u7684\u6574\u6570\u4e2d\uff0c\u6570\u5b577\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u6ee1\u8db3\u9664\u4ee511\u621613\u7684\u4f59\u6570\u4e3a0\u7684\u6761\u4ef6\u3002\n\n\u8fd9\u4e2a\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6cd5\u662f\u904d\u5386\u5c0f\u4e8en\u7684\u6240\u6709\u6574\u6570\uff0c\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u9664\u4ee511\u621613\u7684\u4f59\u6570\u4e3a0\u3002\u5982\u679c\u662f\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6570\u5b57\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u662f7\uff0c\u56e0\u6b64\u8ba1\u6570\u5668\u52a01\u3002\n\n\u8fd9\u662f\u4e00\u4e2a\u7b80\u5355\u7684for\u5faa\u73af\u6765\u5b8c\u6210\u8fd9\u4e2a\u4efb\u52a1\uff1a\n\n```\ncount = 0\nfor i in range(1, n+1):\n    if i % 11 == 0 or i % 13 == 0:\n        count += i.endswith('7')\n```\n\n\u6216\u8005\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u5217\u8868\u63a8\u5bfc\u5f0f\u6765\u7b80\u5316\u8fd9\u4e2a\u5faa\u73af\uff1a\n\n```\ncount = sum(i.endswith('7') for i in range(1, n+1) if i % 11 == 0 or i % 13 == 0)\n```\n\n\u6700\u540e\uff0c\u6211\u4eec\u8fd4\u56decount\u4f5c\u4e3a\u7ed3\u679c\u3002"}
{"task_id": "HumanEval/42", "solution": "def incr_list(l):\n    return [x + 1 for x in l]"}
{"task_id": "HumanEval/48", "solution": "\u8fd9\u662f\u4e00\u4e2a Python \u51fd\u6570\uff0c\u540d\u4e3a `is_palindrome`\uff0c\u5b83\u63a5\u53d7\u4e00\u4e2a\u5b57\u7b26\u4e32\u53c2\u6570 `text`\u3002\u51fd\u6570\u7684\u76ee\u7684\u662f\u68c0\u67e5\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32\u662f\u5426\u4e3a\u56de\u6587\u3002\u56de\u6587\u662f\u6307\u6b63\u8bfb\u548c\u53cd\u8bfb\u90fd\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u3002\n\n\u5728\u8fd9\u4e2a\u51fd\u6570\u4e2d\uff0c\u60a8\u4f7f\u7528\u4e86\u4ee5\u4e0b\u4ee3\u7801\uff1a\n\n1. \u5c06\u8f93\u5165\u7684\u6587\u672c\u8f6c\u6362\u4e3a\u5c0f\u5199\uff0c\u4ee5\u6d88\u9664\u5927\u5c0f\u5199\u7684\u5f71\u54cd\u3002\n2. \u4f7f\u7528\u5b57\u7b26\u4e32\u7684 `replace` \u65b9\u6cd5\u5220\u9664\u7a7a\u683c\u3002\n3. \u4f7f\u7528\u5b57\u7b26\u4e32\u7684 `lower` \u65b9\u6cd5\u5c06\u6240\u6709\u5b57\u7b26\u8f6c\u6362\u4e3a\u5c0f\u5199\u3002\n4. \u4f7f\u7528\u5b57\u7b26\u4e32\u7684 `reversed` \u65b9\u6cd5\u83b7\u53d6\u5b57\u7b26\u4e32\u7684\u53cd\u8f6c\u3002\n5. \u4f7f\u7528\u5b57\u7b26\u4e32\u7684 `split` \u65b9\u6cd5\u5c06\u5b57\u7b26\u4e32\u5206\u5272\u4e3a\u5355\u8bcd\u5217\u8868\u3002\n6. \u4f7f\u7528\u5217\u8868\u7684 `join` \u65b9\u6cd5\u5c06\u5355\u8bcd\u5217\u8868\u91cd\u65b0\u7ec4\u5408\u6210\u5b57\u7b26\u4e32\u3002\n7. \u6bd4\u8f83\u539f\u59cb\u5b57\u7b26\u4e32\u548c\u53cd\u8f6c\u540e\u7684\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u3002\n\n\u6700\u540e\uff0c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\uff0c\u8868\u793a\u8f93\u5165\u5b57\u7b26\u4e32\u662f\u5426\u4e3a\u56de\u6587\u3002"}
{"task_id": "HumanEval/54", "solution": "\u6211\u7406\u89e3\u60a8\u8981\u4f7f\u7528\u5217\u8868\u63a8\u5bfc\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5217\u8868\uff0c\u8be5\u5217\u8868\u53ea\u5305\u542b\u539f\u59cb\u5217\u8868\u4e2d\u4e0d\u91cd\u590d\u7684\u5143\u7d20\u3002\n\n\u8fd9\u662f\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\u7684\u4e00\u79cd\u65b9\u6cd5\uff1a\n\n```"}
{"task_id": "HumanEval/60", "solution": "\u8fd9\u662f\u4e00\u4e2a\u540d\u4e3asum_to_n\u7684\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e00\u4e2a\u6574\u6570n\u4f5c\u4e3a\u8f93\u5165\uff0c\u5e76\u8fd4\u56de\u4ece1\u5230n\u7684\u6240\u6709\u6574\u6570\u4e4b\u548c\u3002\u6839\u636e\u8f93\u5165\u7684n\u503c\uff0c\u8fd9\u4e2a\u51fd\u6570\u53ef\u4ee5\u751f\u6210\u4e0d\u540c\u7684\u8f93\u51fa\u7ed3\u679c\u3002"}
{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    total = 0\n    for char in s:\n        if char.isupper():\n            total += ord(char)\n        elif char.islower():\n            total += ord(char) - 32\n    return total"}
{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    # Check if the list is balanced (palindromic)\n    if q == q[::-1]:\n        # Calculate the sum of the elements\n        total = sum(q)\n        # Check if the sum is less than or equal to the maximum possible weight\n        return total <= w\n    else:\n        return False"}
{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    prime_count = 0\n\n    for digit in num.upper():\n        if digit.isdigit():\n            continue\n\n        if (int(digit) <= 1 and digit != \"0\") or digit in \"2357BDCE\":  # Check if prime\n            prime_count += 1\n\n    return prime_count"}
{"task_id": "HumanEval/84", "solution": "def solve(N):\n    # Initialize a string with the binary representation of N\n    # as a single digit\n    binary_representation = bin(N)[2:]\n    \n    # Initialize a variable to store the sum of the digits\n    total_sum = 0\n    \n    # Loop through each digit in the binary representation\n    for i, bit in enumerate(binary_representation):\n        # If the bit is a 1, add 1 to the total sum\n        if bit == '1':\n            total_sum += 1\n            \n    # Return the total sum as a string of binary numbers\n    return str(total_sum)"}
{"task_id": "HumanEval/90", "solution": "import heapq\n\ndef next_smallest(lst):\n    if not lst:\n        return None\n\n    # \u4f7f\u7528 heapq.nlargest() \u627e\u5230\u5217\u8868\u4e2d\u7684\u7b2c\u4e8c\u4e2a\u6700\u5927\u503c\n    second_largest = heapq.nlargest(2, lst)[1]\n    return second_largest"}
{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    primes = [true_prime]\n    for i in range(2, n + 1):\n        if is_prime(i):\n            primes.append(i)\n    return primes"}
{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    if y <= x:\n        return -1\n    num = x\n    while num <= y:\n        if num % 2 == 0:\n            return num\n        num += 2\n    return -1"}
{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    count = 0\n    for num in arr:\n        if sum(int(d) for d in str(num)) > 0:\n            count += 1\n    return count"}
{"task_id": "HumanEval/114", "solution": "To solve this problem, we can use the Kadane's algorithm. The approach is to maintain a current_sum and a max_sum variable. The current_sum is the sum of elements in the current subarray, and the max_sum is the maximum sum of all elements in the current subarray. We iterate through the elements in the input array and update the current_sum and max_sum accordingly. Finally, we return the max_sum.\n\nHere's the Python code for the Kadane's algorithm:\n\n```"}
{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    sorted_arr = sorted(arr)\n    max_k = k\n    end = max_k - 1\n\n    if end >= 0 and sorted_arr[end] > sorted_arr[max_k]:\n        max_k -= 1\n\n    return sorted_arr[:max_k]"}
{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    # \u53bb\u9664\u91cd\u590d\u5143\u7d20\n    unique_lst = []\n    for item in lst:\n        if item not in unique_lst:\n            unique_lst.append(item)\n\n    # \u6bd4\u8f83\u662f\u5426\u6709\u9006\u5e8f\u5143\u7d20\n    for i in range(len(unique_lst) - 1):\n        if unique_lst[i] > unique_lst[i + 1]:\n            return False\n\n    return True"}
{"task_id": "HumanEval/132", "solution": "def is_nested(string):\n    # Check if the string starts and ends with square brackets\n    if string.startswith('[') and string.endswith(']'):\n        # Check if there is a match for the middle part\n        middle = string[1:-1]\n        if '[' in middle and ']' in middle:\n            # Check if the nested brackets are within each other\n            nested = True\n            for i in range(len(middle)):\n                if middle[i] == '[' and middle[i+1] == ']':\n                    i += 1\n                    if i == len(middle) - 1 or middle[i] != '[' or middle[i+1] != ']':\n                        nested = False\n            string = middle\n    return nested"}
{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    even_numbers = set(range(2, 1000))\n    \n    for i in even_numbers:\n        # Check if there are two even numbers j and k, such that i = j + k\n        for j in even_numbers:\n            if i != j:\n                k = i - j\n                if k in even_numbers and i == 2 * j + 2 * k:\n                    return True\n    return False"}
{"task_id": "HumanEval/144", "solution": ""}
{"task_id": "HumanEval/150", "solution": "This function appears to be designed to check if a given number `n` is a prime number, based on the values of `x` and `y`. If `n` is a prime number, the function should return the value of `x`. If `n` is not a prime number, the function should return the value of `y`.\n\nHowever, this function seems to be missing a few required lines of code. The function definition looks like it should be complete, but it doesn't seem to be doing anything. If you provide the necessary lines of code to complete the function, it should work as intended."}
{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    suffix_to_roman = {\n        1: 'I',\n        5: 'V',\n        10: 'X',\n        50: 'L',\n        100: 'C',\n        500: 'D',\n        1000: 'M'\n    }\n\n    # Convert the number to a string of digits, with the last digit on the left\n    # being the largest, and the smallest on the right\n    digits = str(number)[::-1]\n    miniroban = ''\n\n    # Loop through each digit, appending the corresponding Roman numeral to the result\n    for digit in digits:\n        if int(digit) <= 3:  # Special case for 1, 4, and 9, which don't have mini-Roman numeral equivalents\n            miniroban += digit\n        else:\n            miniroban += suffix_to_roman[int(digit)]\n\n    return miniroban"}
{"task_id": "HumanEval/162", "solution": "import md5\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    return md5.new(text).hexdigest()"}
