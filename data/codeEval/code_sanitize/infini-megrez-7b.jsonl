{"task_id": "HumanEval/0", "solution": "from collections import Counter\nimport numpy as np\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Assuming `Counter` has been imported to provide support for the `sum()` and `count()` methods\n    counts = Counter(numbers)\n\n    # Check if any two elements have a closer distance\n    closest_elements = np.argsort(counts.argsort())[::-1]\n\n    return closest_elements <= threshold"}
{"task_id": "HumanEval/6", "solution": "from typing import List\ndef parse_nested_parens(paren_string):\n    \"\"\" Implement parse_nested_parens to parse the parenthesized expressions. \"\"\"\n    # 1. Paren_string: the string to parse\n    # 2. List[int]: the list to store the parsed parenthesized expressions\n\n    parsed_list = []\n    next_level = 0 # Initialize the number of levels of nesting\n    for _ in range(1, len(paren_string.split(''))):\n        # Evaluate the current group of parentheses.\n        level = next_level\n        # Convert each parenthesized expression to an int.\n        # E.g. ((())) is 1, ((())) is 2.\n        numbers = [int(group) for group in paren_string.split('')]\n        # Add the level number to the list of ints.\n        parsed_list.extend(numbers)\n\n    # Return the parsed list.\n    return parsed_list"}
{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\n# Create a list of strings.\nstrings = [['a', 'b', 'c'], ['a', 'bb', 'ccc']]\n\n# Define the function that returns the longest string.\ndef longest(strings):\n    \"\"\" Return the longest string from the list of strings.\n    If multiple strings are the same length, return the first one in the list.\n    Otherwise, return None.\n    \"\"\"\n    return strings[-1] if None in strings else strings[0]"}
{"task_id": "HumanEval/18", "solution": "def how_many_times(string, substring):\n    \"\"\" \u8ba1\u7b97\u5b50\u5b57\u7b26\u4e32\u5728\u4e3b\u5b57\u7b26\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570. \u5047\u8bbe\u4e3b\u5b57\u7b26\u4e32\u548c\u5b50\u5b57\u7b26\u4e32\u9700\u8981\u662f\u4e0d\u91cd\u53e0\u7684.\n    \u53c2\u6570:\n     - string: \u4e3b\u5b57\u7b26\u4e32\n     - substring: \u8981\u5728\u5176\u4e2d\u8ba1\u6570\u7684\u5b50\u5b57\u7b26\u4e32\n    \u8fd4\u56de:\n     - how_many_times(string, substring) \u5bf9\u4e8e\u91cd\u53e0\u90e8\u5206\u7684\u51fa\u73b0\u6b21\u6570\n     - how_many_times(string, substring) >= 0 \u5bf9\u4e8e\u4e0d\u91cd\u53e0\u90e8\u5206\u7684\u51fa\u73b0\u6b21\u6570\n     \"\"\"\n    # \u4f7f\u7528\u5185\u7f6e\u65b9\u6cd5 replace \u5c06\u5b50\u5b57\u7b26\u4e32\u79fb\u52a8\u5230\u4e3b\u5b57\u7b26\u4e32\u4e2d\n    string_with_substrate = string + [substring]\n    # \u8ba1\u7b97\u65b0\u5b57\u7b26\u4e32\u4e2d\u5b50\u5b57\u7b26\u4e32\u51fa\u73b0\u7684\u6b21\u6570\n    return sorted(how_many_times(string_with_substrate, substring))"}
{"task_id": "HumanEval/24", "solution": "def largest_divisor(n):\n    if n <= 1:\n        return 1\n    d = largest_divisor(n - 1)\n    return d"}
{"task_id": "HumanEval/30", "solution": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    :param l: a list of integers\n    :return: a list of positive integers \"\"\"\n\n    # Implementation based on the provided documentation:\n    # return [x for x in l if x >= 0]\n\n# Or, using the `filter` function instead of implementing it in code:\n# return list(filter(str.isprime, [x for x in l if x >= 0]))\n"}
{"task_id": "HumanEval/36", "solution": ""}
{"task_id": "HumanEval/42", "solution": "def incr_list(l):\n    # \u5047\u8bbe\u8fd9\u4e2a\u5217\u8868\u7684\u5143\u7d20\u7c7b\u578b\u662f\u6574\u6570\n    num_elements = len(l)\n    # \u8ba1\u7b97\u6bcf\u4e2a\u5143\u7d20\u5c06\u88ab\u589e\u52a0\u7684\u503c\n    inc_step = (num_elements + 1) // num_elements\n    # \u8c03\u7528\u539f\u5217\u8868\u65b9\u6cd5\uff0c\u5c06\u6bcf\u4e2a\u5143\u7d20\u589e\u52a0 1\n    return l * inc_step // inc_step + [l[0] + (inc_step - 1) if num_elements % inc_step == 0]"}
{"task_id": "HumanEval/48", "solution": ""}
{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str):\n    return s0 == s1"}
{"task_id": "HumanEval/60", "solution": ""}
{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    sum = 0\n    # 遍历字符串中的每个字符，如果为上标字符，则将数字 sum 加倍\n    for char in s:\n        if char.isupper():\n            sum += sum * (char.isupper() == 'A' and 65 <= ord(char) <= 122 or char.isupper() == 'a' and 32 <= ord(char) <= 122)\n        else:\n            if ord(char) <= 65:\n                sum += 1\n        # 对于字符' '，忽略\n        else:\n            pass\n    return sum"}
{"task_id": "HumanEval/72", "solution": "import itertools\n\ndef will_it_fly(q, w):\n    # q can be any palindromic list of any type (including homogeneous and heterogeneous)\n    if not (isinstance(q, list) and (all ispalindromes(q) or all ispalindromes(q[:1]))):\n        raise ValueError(\"q must be a list of palindromes\")\n\n    if not (isinstance(w, float) and (max(iteritems(q)) <= max(*(iteritems(w))))):\n        raise ValueError(\"w must be a weight that can be supported by the given q\")\n\n    return True"}
{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    \"\"\"Hex key count of prime numbers.\n\n    You have been tasked to write a function that receives \n    a string representing a hexadecimal number as a string and counts\n    the number of hexadecimal digits that are primes (prime number, or a \n    prime, is a natural number greater than 1 that is not a product of two smaller \n    natural numbers).\n\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, B (decimal 11), D (decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A, B, C, D, E, F are always uppercase.\n    \"\"\"\n    strings = re.findall(r'[A-Za-z]', num)  # Convert string to re.findall regex\n    prime_count = 0\n    for char in strings:  # For each character in the string\n        if re.match(char, num):  # If the character in strings matches the regex\n            prime_count += 1  # Increase count of prime digits by 1\n\n    return prime_count"}
{"task_id": "HumanEval/84", "solution": "import bin\ndef solve(N):\n    # Convert the number to binary\n    binary = ''.join(map(ord, [range(N) if _ <= ord(N) else [] for _ in range(N)]))\n    # Append the leading '0' if needed\n    return ''.join(binary[:8]) + '0' * (N // 9)"}
{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    # \u539f\u59cb\u5217\u8868\n\n    # \u4f7f\u7528sorted\u6392\u5e8f\u540e\u53d6\u7b2c\u4e8c\u5c0f\u7684\n    sorted_lst = sorted(lst, key=lambda x: x)\n    \n    # \u8fd4\u56de\u7b2c\u4e8c\u5c0f\u7684\u6570\u5b57\n    return sorted_lst[1]\n"}
{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    # Implement the function to determine the prime numbers and return the first n primes\n    def prime_numbers(limit):\n        # Generate a list of all integers from 1 up to limit\n        # Ignore all multiples of 2 and 3 (since they are not prime numbers)\n        # Begin with 1 to avoid returning the first two numbers\n        # Use the Lucas numbers (0, 1, 3, 4, 7, 11, 18, 29, 47, 76, 127) as a good starting point\n        numbers = [1, 2, 3, 4, 7, 11, 13, 17, 19, 23, 29, 31, 37, 43, 47, 53, 59, 61, 67, 83, 89, 97, 101, 109, 113, 127, 131, 139, 143, 147, 157]\n        # Check if each number is prime\n        while True:\n            for num in numbers:\n                if num not in set(range(2, int(num) + 1) + set(range(2*n + 1, int(num) + 1) + set(range(2*n + 1, int(num) + 1) + set(range(3, int(num) + 1) + set(range(3, int(num) + 1) + set(range(num + 1, int(num) + 1) + set(range(num + 1, int(num) + 1) + set(range(num + 2, int(num) + 1) + set(range(num + 2, int(num) + 1) + set(range(num + 3, int(num) + 1) + set(range(num + 3, int(num) + 1) + set(range(num, int(num) + 1) + set(range(num, int(num) + 1))) + set(range(num + 4, int(num) + 1) + set(range(num, int(num) + 1) + set(range(num + 5, int(num) + 1) + set(range(num + 5, int(num) + 1) + set(range(num, int(num) + 1) + set(range(num, int(num) + 1))) + ...\n                           + set(range(num + 2*n, int(num) + 1) + set(range(num + 2*n + 1, int(num) + 1) + set(range(num + 3*n + 1, int(num) + 1) + set(range(num + 3*n + 1, int(num) + 1) + set(num, int(num) + 1) + set(num, int(num) + 1) + ...\n                            + set(range(num + (4*n + 1), int(num) + 1) + set(range(num + (4*n + 1), int(num) + 1) + ...\n                             if num < int(num) and num not in set(exceptions)):\n                                 break\n                  # Skip multiples of 3 and 4\n                  numbers = [num] if not num in set(range(2, int(num) + 1) + set(range(2*n + 1, int(num) + 1) + set(range(2*n + 1, int(num) + 1) + set(range(3, int(num) + 1) + set(3, int(num) + 1) + ...\n                                  ) + ...\n                           + set(range(num + 1, int(num) + 1) + set(num, int(num) + 1) + ...\n                          prime_numbers(limit)\n                        return prime_numbers\n    count_up_to = function"}
{"task_id": "HumanEval/102", "solution": "import itertools\n\ndef choose_num(x, y):\n    if x <= y:\n        return x\n    for i in range(x, y):\n        if i % 2 == 0:\n            return i\n    return -1"}
{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    # \u5b9a\u4e49\u6b63\u6570\u548c\u8d1f\u6570\u7684\u9996\u6570\u5b57\n    positive_sign = -1 if arr[-1] < 0 else 1\n    negative_sign = -1 if arr[-1] < 0 else 1\n    \n    # \u8fd4\u56de\u503c\u8868\u793a\u6b63\u6570\u7684\u6570\u91cf\uff0c\u51cf\u53bb\u8d1f\u6570\u7684\u6570\u91cf\uff0c\u9664\u4ee5\u8d1f\u6570\u7684\u6570\u91cf\n    return positive_sign - negative_sign / 2 + 1"}
{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    nums_sorted = sorted(nums)\n    \n    # Process the sub-arrays one by one\n    for sub_nums in nums_sorted[::-1]:\n        # Sort the sum of the sub-array\n        sorted_sums = sorted(sum(sub_nums))\n        \n        # Check if the sum of the current sub-array is less than or equal to the sum of the next sub-array\n        if sorted_sums[0] <= sorted_sums[1]:\n            # Merge the two sub-arrays\n            result = sorted_sums[0][:] merged_sum = sorted_sums[1][:]\n            merged_sum = sorted_sums[0][::-1] + merged_sum[:-1]\n            \n        # Repeat this process until there are no more sub-arrays left to merge\n        if len(sub_nums) == len(nums_sorted):\n            # Get the minimum sum of all non-empty sub-arrays\n            return sorted_sums[0]\n        return sorted_sums[1:]"}
{"task_id": "HumanEval/120", "solution": ""}
{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    return bool(sorted(lst) == lst)"}
{"task_id": "HumanEval/132", "solution": "is_nested = lambda s: [\n    '['.join(char) for char in s] == s\n    if not char:\n        return True\n    # \u5bf9\u4e8e\u6ca1\u6709\u5b57\u7b26\u7684\u5b50\u5e8f\u5217\uff0c\u5982\u679c\u6240\u6709\u5d4c\u5957\u7684\u62ec\u53f7\u90fd\u88ab\u6c42\u548c\uff0c\u5219\u4e0d\u6ee1\u8db3\u6761\u4ef6\uff0c\u56e0\u4e3a\u8fd9\u4e0d\n    # \u662f\u4e00\u4e2a\u6709\u6548\u7684\u5b50\u5e8f\u5217\u3002\n    # \u4f8b\u5982\uff0c\u5bf9\u4e8e '[]]'][[]']', \u5b50\u5e8f\u5217 '[[]]' \u6216 '[]' \u90fd\u4e0d\u6ee1\u8db3\u6761\u4ef6\u3002\n    # '[[]]' \u4f1a\u88ab\u5904\u7406\u4e3a\u65e0\u6548\u7684\u5b57\u7b26\u4e32\uff0c\u800c '[]' \u5219\u4f1a\u88ab\u5904\u7406\u4e3a\u6709\u6548\u7684\u5b50\u5e8f\u5217\u3002\n    # \u5bf9\u4e8e '[][]'][[][]', '[[]]' \u4f1a\u88ab\u5904\u7406\u4e3a\u6709\u6548\u7684\u5b50\u5e8f\u5217\u3002\n    \n    # \u5904\u7406\u7279\u6b8a\u5b57\u7b26 '['\u548c']'\uff0c\u5b83\u4eec\u4f1a\u88ab\u5ffd\u7565\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e0d\u4f1a\u5f71\u54cd\u662f\u5426\u662f\u6709\u6548\u7684\u5b50\u5e8f\u5217\u3002\n    # \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u9700\u8981\u786e\u4fdd\u5ffd\u7565\u6389\u7279\u5b9a\u7684\u5b57\u7b26\u3002\n    \n    # \u5904\u7406\u5b57\u7b26\u4e32 '[]' \u548c '[' \u4f1a\u8fd4\u56de\u65e0\u6548\u7684\u5b50\u5e8f\u5217\uff0c\u56e0\u4e3a\u5b83\u4eec\u65e0\u6cd5\u95ed\u5408\u3002\n    # \u5982\u679c\u6211\u4eec\u6ca1\u6709 '['\u548c']'\u4f5c\u4e3a\u4f8b\u5916\uff0c\u8fd9\u5c06\u662f\u6709\u610f\u4e49\u7684\u5b50\u5e8f\u5217\u3002\n    \n    # \u8fd9\u662f\u4e00\u79cd\u7b80\u5355\u7684\u9012\u5f52\uff0c\u5b83\u53ea\u5728\u6700\u5e95\u5c42\u6570\u91cf\u7ea7\u4e0a\u5de5\u4f5c\uff0c\u800c\u4e0d\u662f\u5728\u4e8c\u5143\u6811\u72b6\u7ed3\u6784\u4e0a\u3002\n    # \u5b9e\u9645\u4e2d\u7684\u5b57\u7b26\u4e32\u5904\u7406\u901a\u5e38\u4e0d\u4f1a\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u5b9e\u73b0\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u53ef\u4ee5\u5305\u542b\u590d\u6742\u7684\n    # \u5d4c\u5957\u6a21\u5f0f\uff0c\u8fd9\u901a\u5e38\u9700\u8981\u66f4\u6df1\u5c42\u6b21\u7684\u9012\u5f52\u3002\n    \n    # \u5904\u7406 '[][]'][[][]' \u4f1a\u5931\u8d25\uff0c\u56e0\u4e3a\u4efb\u4f55\u6709\u6548\u7684\u5b50\u5e8f\u5217\u90fd\u65e0\u6cd5\u5305\u542b\u6240\u6709\u8fd9\u4e9b\u62ec\u53f7\u3002\n    return '['.join(char) for char in s] == s\n]"}
{"task_id": "HumanEval/138", "solution": ""}
{"task_id": "HumanEval/144", "solution": "import re\n\ndef simplify(x, n):\n    \"\"\"\n    This function has been written to mimic the Python `re.sub` method, which is used to\n    perform the search for the pattern \"n\" in the string `x`. The `re.sub` method will\n    return a string if the pattern \"n\" occurs in the first argument, and return the original string\n    if the pattern \"n\" is found in the second argument.\n\n    The `re.sub` method uses the following regular expression:\n\n    /(.+?)\\1/g\n\n    This regular expression will find and replace instances of the string \"n\" with the string\n    in the second argument, and it will not modify the current string.\n\n    Note that your fractional representation of the denominator must be a power of two so that\n    the algorithm can determine the fractional representation of the denominator in the simplified\n    result.\n\n    \"\"\"\n    # Convert strings to re regular expression strings\n    numerator = re.sub('/', '', n, x)\n    denominator = re.sub('/\\d+?\\d*?/\\d', '', x, numerator)\n\n    # Check if the simplified expression is a fraction with a denominator that is a power of two\n    if denominator.find('') > 0:\n        if denominator[-1] % 2 == 1:\n            return True\n    # Otherwise, the denominator is not a power of two and the fraction is not simplified\n    return False"}
{"task_id": "HumanEval/150", "solution": ""}
{"task_id": "HumanEval/156", "solution": "roman_numbers = {\n    1: 'I',\n    2: 'II',\n    3: 'III',\n    4: 'IV',\n    5: 'V',\n    6: 'VI',\n    7: 'VII',\n    8: 'VIII',\n    9: 'IX',\n  # ... omitted for brevity\n   1000: 'CXC'\n}\n\ndef int_to_mini_roman(number):\n    roman_digits = roman_numbers[number] if number in roman_numbers else '?'\n    return roman_digits.ljust(' ' * len(roman_digits), ' ')"}
{"task_id": "HumanEval/162", "solution": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n    \"\"\"\n    if text:\n        # Implement hash the string to a 128-bit hash value\n        return hashlib.md5().update(text).hexdigest()\n    else:\n        # If it's empty, return None\n        return None"}
