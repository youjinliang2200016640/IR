{"task_id": "HumanEval/0", "solution": "def has_close_pairs(numbers_list: List[float], closeness_threshold: float) -> bool:\n    \"\"\" Check if there are any two numbers in the list that are closer to each other than the given threshold.\n\n    Args:\n        numbers_list (List[float]): The list of numbers to check.\n        closeness_threshold (float): The maximum distance between two numbers that are considered close.\n\n    Returns:\n        bool: True if there are any two close numbers, False otherwise.\n\n    Example:\n        >>> has_close_pairs([1.0, 2.0, 3.0], 0.5)  # False\n        >>> has_close_pairs([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  # True\n    \"\"\"\n    if not numbers_list or len(numbers_list) < 2 or closeness_threshold <= 0:\n        return False\n\n    window_size = len(numbers_list) - 1\n    for i in range(window_size):\n        current_sum = 0\n        for j in range(i, min(i + window_size, len(numbers_list))):\n            current_sum += abs(numbers_list[i] - numbers_list[j])\n            if current_sum > closeness_threshold:\n                break\n        else:\n            current_sum -= abs(numbers_list[i] - numbers_list[j])\n            if current_sum > closeness_threshold:\n                return True\n\n    return False\n"}
{"task_id": "HumanEval/6", "solution": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Initialize an empty list to store the nesting levels\n    levels = []\n\n    # Iterate through the input string\n    for char in paren_string:\n        # If the current character is an open parenthesis, increase the current level by 1\n        if char == '(':\n            levels.append(levels.index(None) + 1)\n        # If the current character is a close parenthesis, decrease the current level by 1\n        elif char == ')':\n            levels.pop()\n\n    # Return a list of the nesting levels, with the deepest levels at the end\n    return levels[::-1]"}
{"task_id": "HumanEval/12", "solution": ""}
{"task_id": "HumanEval/18", "solution": ""}
{"task_id": "HumanEval/24", "solution": ""}
{"task_id": "HumanEval/30", "solution": "def get_positive(l):\n    return [x for x in l if x > 0]"}
{"task_id": "HumanEval/36", "solution": ""}
{"task_id": "HumanEval/42", "solution": ""}
{"task_id": "HumanEval/48", "solution": ""}
{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str) -> bool:\n    if not s0 or not s1:\n        return NotImplemented\n    if len(s0) != len(s1):\n        return False\n    for char0, char1 in zip(s0, s1):\n        if char0 != char1:\n            return False\n    return True"}
{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int):\n    return sum(range(1, n+1))"}
{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    sum = 0\n    for i in range(len(s)):\n        if s[i].isupper():\n            sum = sum + ord(s[i])\n    return sum"}
{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    \"\"\"\n    Return True if the object q will fly, and False otherwise.\n\n    An object q will fly if it's balanced (a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n    \"\"\"\n    # Base case: empty list\n    if not q:\n        return True\n\n    # Check if the list is balanced (a palindrome)\n    if q[0] != q[-1]:\n        return False\n\n    # Calculate the sum of the elements\n    sum = 0\n    for x in q:\n        sum += x\n\n    # Check if the sum is less than or equal to the maximum possible weight\n    if sum <= w:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    prime_digits = {2, 3, 5, 7, 11, 13, 17}\n    count = 0\n    for dig in num:\n        if dig.isdigit() and dig in prime_digits:\n            count += 1\n    return count"}
{"task_id": "HumanEval/84", "solution": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    if N == 0:\n        return \"0\"\n    else:\n        sum = 0\n        while N > 0:\n            sum = (sum << 1) + (N % 2)\n            N //= 2\n        return format(sum, 'b')"}
{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    if len(lst) <= 1:\n        return None\n    return min(lst[1:], key=lst.index)"}
{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    prime_list = []\n    for i in range(2, int(n**0.5) + 1):\n        is_prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            prime_list.append(i)\n    return prime_list[:n]"}
{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    \"\"\"Return the biggest even integer number in [x, y] inclusive, or -1 if no such number exists.\"\"\"\n    if x < y:\n        # If x is less than y, we can just check the even numbers in the range\n        for i in range(x, y+1, 2):\n            if i >= x and i <= y:\n                return i\n    else:\n        # If x is greater than or equal to y, we need to check both the even and odd numbers\n        # in the range, since the biggest even number may be greater than x\n        for i in range(x, y+1):\n            if i % 2 == 0 and i >= x and i <= y:\n                return i\n    return -1"}
{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    return sum(digit > 0 for digit in map(lambda x: x if x >= 0 else -x, arr))"}
{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    # If the input array is empty, return -1\n    if not nums:\n        return -1\n\n    # Initialize a variable to keep track of the minimum sum\n    min_sum = float('inf')\n\n    # Iterate over the input array\n    for i in range(len(nums)):\n        # Calculate the sum of the sub-array from the current index to the end of the array\n        current_sum = sum(nums[i:])\n\n        # If the current sum is less than the minimum sum, update the minimum sum\n        if current_sum < min_sum:\n            min_sum = current_sum\n\n    # Return the minimum sum\n    return min_sum"}
{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list\n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if len(arr) == 0:\n        return []\n    if k > len(arr):\n        return [arr[0]] * k\n    if k == 1:\n        return [arr[0]]\n\n    # sort the array in descending order\n    arr.sort(reverse=True)\n\n    # get the top k elements\n    return arr[0:k]"}
{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    \"\"\"\n    Given a list of integers, return whether or not they are sorted in ascending order.\n    If the list has more than one duplicate of the same number, return False.\n    \"\"\"\n    if len(lst) < 2:\n        return True\n\n    for i in range(1, len(lst)):\n        if lst[i] <= lst[i - 1]:\n            continue\n        return False\n\n    return True"}
{"task_id": "HumanEval/132", "solution": "def is_nested(string):\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append('open')\n        elif char == ']':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n        else:\n            continue\n    return len(stack) > 0"}
{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    if n % 2 != 0:\n        return False\n    if n <= 2:\n        return True\n    return all(n % i == 0 for i in range(4, int(n ** 0.5) + 1, 2))"}
{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    numerator, denominator = x.split('/')\n    if numerator == denominator:\n        return True\n    elif numerator == 0 or denominator == 0:\n        return False\n    else:\n        return simplify(numerator/denominator, n)"}
{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    if n == 1 or n % 2 == 0:\n        return y\n    else:\n        return x"}
{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its Roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n    \"\"\"\n    if number <= 100:\n        # For numbers up to 100, we can use a simple lookup table\n        lookup = {\n            1: 'i',\n            2: 'ii',\n            3: 'iii',\n            4: 'iv',\n            5: 'v',\n            6: 'vi',\n            7: 'vii',\n            8: 'viii',\n            9: 'ix',\n            10: 'x'\n        }\n        return lookup[number]\n    elif number <= 500:\n        # For numbers between 101 and 500, we can use a combination of the\n        #   lookup table and some simple rules for forming the larger\n        #   numerals\n        lookup = {\n            101: 'cxxi',\n            200: 'ccx',\n            300: 'ccc',\n            400: 'cdx',\n            500: 'd'\n        }\n        if number >= 101 and number <= 400:\n            return lookup[number // 100] + lookup[number % 100]\n        else:\n            return lookup[number]\n    else:\n        # For numbers over 500, we can use the standard Roman numeral\n        #   system, with the exceptions that we only use the first\n        #   five letters (I-V) for the units place, and we use the\n        #   letter 'm' for multiples of 1000\n        units = number % 10\n        tens = (number // 10) % 10\n        hundreds = (number // 100) % 10\n        thousands = (number // 1000)\n        if thousands > 0:\n            return thousands + 'm' + hundreds + tens + units\n        else:\n            return hundreds + tens + units"}
{"task_id": "HumanEval/162", "solution": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
