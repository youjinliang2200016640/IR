{"task_id": "HumanEval/0", "solution": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    return len([num for num, num2 in zip(numbers, numbers[1:]) if abs(num - num2) < threshold]) > 0"}
{"task_id": "HumanEval/6", "solution": "def parse_nested_parens(paren_string: str) -> List[int]:\n    stack: List[int] = []\n    max_depth = 0\n    result = []\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(-1)\n        elif char == ')':\n            if not stack or stack.pop() != -1:\n                max_depth = max(max_depth, result[-1] + 1)\n                result.append(result[-1] + 1)\n\n    while stack:\n        max_depth = max(max_depth, result[-1] + 1)\n        result.append(result[-1] + 1)\n\n    return result"}
{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n\n    return longest_string"}
{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    index = 0\n    while True:\n        index = string.find(substring, index)\n        if index == -1:\n            break\n        count += 1\n        index += 1\n    return count"}
{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Initialize the divisor to be n\n    divisor = n\n    # Loop through the range smaller than n, i.e., from 1 to n-1\n    for i in range(1, n):\n        # Check if i divides n without remainder\n        if n % i == 0:\n            # If so, update the divisor to be the larger of n and i, as this is the largest divisor\n            divisor = max(divisor, i)\n    # Return the largest divisor\n    return divisor"}
{"task_id": "HumanEval/30", "solution": "get_positive = lambda l: [x for x in l if x > 0]"}
{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n):\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0) or (i % 13 == 0):\n            num_digits = str(i).count('7')\n            count += num_digits\n    return count"}
{"task_id": "HumanEval/42", "solution": "def incr_list(l: list):\n    return [x + 1 for x in l]"}
{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    # Reverse the given text\n    reversed_text = text[::-1]\n\n    # Check if the reversed text is equal to the original text\n    return text == reversed_text"}
{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str):\n    if len(s0) != len(s1):\n        return False\n\n    for c in s0:\n        if c not in s1 or s1.count(c) < s0.count(c):\n            return False\n\n    return True"}
{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int):\n    return sum(range(1, n + 1))"}
{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    # Initialize the sum to 0\n    sum_digits = 0\n\n    # Iterate through the string, ignoring first character (if any)\n    for i in range(len(s)):\n        # Get the character at the current index\n        char = s[i]\n\n        # Check if the character is an uppercase letter\n        if char.isupper():\n            # Add the ASCII value of the character to the sum\n            sum_digits += ord(char)\n\n    # Return the sum\n    return sum_digits"}
{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    if len(q)%2 == 0 and sum(q) <= w:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/78", "solution": "def hex_prime_count(num):\n    num_list = list(num)\n    count = 0\n    for digit in num_list:\n        if is_prime(int(digit)):\n            count += 1\n        if digit in \"ABCDEF\":\n            count += 1\n    return count\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# Test the function\ntest_numbers = [\n    \"AB\",\n    \"1077E\",\n    \"ABED1A33\",\n    \"123456789ABCDEF0\",\n    \"2020\"\n]\n\nfor num in test_numbers:\n    print(f\"{num}: {hex_prime_count(num)}\")"}
{"task_id": "HumanEval/84", "solution": "def solve(N):\n    # Get the binary representation of the number\n    binary_N = bin(N).replace(\"0\", \"\")\n\n    # Initialize the sum of digits to 0\n    total_sum = 0\n\n    # Iterate through the binary representation of the number and add the corresponding digits\n    for digit in binary_N:\n        total_sum += int(digit)\n\n    # Return the total sum of digits\n    return str(total_sum)"}
{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    # If the list is empty or has only one element, return None\n    if len(lst) <= 1:\n        return None\n\n    # Sort the list\n    lst.sort()\n\n    # Find the second smallest element\n    return lst[1]"}
{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    primes = []\n    for num in range(2, n+1):\n        if is_prime(num):\n            primes.append(num)\n    return primes\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    if x >= y:\n        return -1\n    elif x % 2 == 0:\n        return x\n    else:\n        for i in range(x + 1, y):\n            if i % 2 == 0:\n                return i\n    return -1"}
{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    count = 0\n    for num in arr:\n        if abs(sum(int(digit) for digit in str(num))) > 0:\n            count += 1\n    return count"}
{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums: List[int]) -> int:\n    size = len(nums)\n    if size == 0:\n        return 0\n    if size == 1:\n        return nums[0]\n    left = 0\n    right = 1\n    min_sum = float('inf')\n    while right < size:\n        cur_sum = nums[left] + nums[right]\n        if cur_sum < min_sum:\n            min_sum = cur_sum\n        if cur_sum >= 0:\n            left += 1\n        right += 1\n    return min_sum"}
{"task_id": "HumanEval/120", "solution": "class Solution:\n    def findMaximums(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        min_heap = [-arr[i] for i in range(k)]\n        for i in range(k, len(arr)):\n            heappush(min_heap, -arr[i])\n            max_val = -min_heap[0]\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums2(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            heappush(max_heap, -arr[i])\n            max_val = -max_heap[0]\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums3(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -min(-arr[i], -min_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums4(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -min(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums5(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n    \n    def findMaximums6(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n      \n    def findMaximums7(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums8(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums9(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums10(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums11(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums12(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums13(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums14(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums15(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums16(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums17(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums18(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums19(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\n    def findMaximums20(self, arr, k):\n        max_heap = [-arr[i] for i in range(k)]\n        heapify(max_heap)\n        for i in range(k, len(arr)):\n            max_val = -max(-arr[i], -max_heap[0])\n            if max_val > max_heap[0]:\n                heappop(max_heap)\n                heappush(max_heap, max_val)\n        return max_heap\n\ndef maximum(arr, k):\n    return Solution().findMaximums(arr,k)"}
{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    if len(lst) < 2:\n        return True\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i-1]:\n            return False\n    return True"}
{"task_id": "HumanEval/132", "solution": "def is_nested(string):\n    if not string:\n        return False\n\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack or stack.pop() != '[':\n                return False\n        else:\n            return False\n\n    return not stack"}
{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    sum_of_evens = sum([x for x in range(2, n) if x % 2 == 0])\n    return sum_of_evens == n\n\n# Test cases\nprint(is_equal_to_sum_even(4))  # False\nprint(is_equal_to_sum_even(6))  # False\nprint(is_equal_to_sum_even(8))  # True"}
{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    # Get the numerator and denominator of x and n\n    numerator_x, denominator_x = x.split('/')\n    numerator_n, denominator_n = n.split('/')\n\n    # Check if the denominator of x and n are equal\n    if denominator_x == denominator_n:\n        # Calculate the result\n        result = float(numerator_x) * float(denominator_n) // float(denominator_x)\n\n        # Check if the result is a whole number\n        return abs(result - int(result)) < 1e-9\n\n    return False"}
{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    if n % 2 == 0:\n        return x\n    else:\n        return y"}
{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    if number < 100:\n        if number in [100, 400]:\n            return str(number)\n        elif number in [90, 60, 30, 20, 10]:\n            return str(number) + str(number // 10)\n        else:\n            return str(number // 10) + str(number % 10)\n    elif number < 400:\n        return str(number // 100) + str(number % 100) + str(number // 100 // 10)\n    else:\n        return str(number // 1000) + str(number // 1000 // 100) + str(number // 1000 // 100 // 10)\n    \n    return str(number)"}
{"task_id": "HumanEval/162", "solution": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    md5 = hashlib.md5(text.encode('utf-8')).hexdigest()\n    return md5"}
