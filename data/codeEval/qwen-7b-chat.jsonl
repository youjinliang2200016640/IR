{"task_id": "HumanEval/0", "solution": "```python\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    return len(set([abs(num - num2) for num, num2 in zip(numbers, numbers[1:])])) > 1\n```"}
{"task_id": "HumanEval/6", "solution": "Here's a possible implementation of the `parse_nested_parens` function:\n```python\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def count_parens(string: str) -> int:\n        count = 0\n        for char in string:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return -1\n        return count\n\n    def parse_group(string: str) -> List[int]:\n        result = []\n        for i, char in enumerate(string):\n            if char == '(':\n                result.append(count_parens(string[i+1:]))\n            else:\n                if result and result[-1] > 0:\n                    result[-1] -= 1\n                else:\n                    result.append(count_parens(string[i:]))\n        return result\n\n    groups = paren_string.split(' ')\n    result = []\n    for group in groups:\n        result.extend(parse_group(group))\n    return result\n```\n\nThis function first defines a helper function `count_parens` that recursively counts the number of opening and closing parentheses in a given string. Then, it defines another helper function `parse_group` that recursively parses a group of parentheses by counting the number of opening and closing parentheses in each substring, and returning the deepest level of nesting.\nFinally, the `parse_nested_parens` function splits the input string into groups based on spaces, and calls `parse_group` on each group to obtain a list of deepest nesting levels. It then returns the concatenation of these lists."}
{"task_id": "HumanEval/12", "solution": "This is a Python function that takes a list of strings as input and returns the longest string in the list, or None if the list is empty. If there are multiple strings of the same length, the function returns the first one encountered.\nHere's a step-by-step explanation of how the function works:\n\n  1. The function takes a list of strings as its input parameter and assigns it to the variable `strings`.\n  2. The function uses the `len()` function to determine the length of the longest string in the list. It then assigns this length to the variable `longest_length`.\n  3. The function checks if the list is empty using the `len()` function again. If the list is empty, the function returns None.\n  4. If the list is not empty, the function iterates over each string in the list using a for loop.\n  5. For each string, the function checks if its length is greater than `longest_length`. If it is, the function updates `longest_length` to the length of the current string and assigns the current string to the variable `longest_string`.\n  6. After iterating over all the strings, the function returns the value of `longest_string`.\n\nHere's an example of how the function would be used:\n\n```python\n>>> longest(['a', 'b', 'c'])\n'a'\n\n>>> longest(['a', 'bb', 'ccc'])\n'ccc'\n\n>>> longest([])\nNone\n```"}
{"task_id": "HumanEval/18", "solution": "Here's one way to implement the `how_many_times` function in Python:\n```python\ndef how_many_times(string: str, substring: str) -> int:\n    count = 0\n    index = 0\n    while index < len(string):\n        index = string.find(substring, index)\n        if index == -1:\n            break\n        count += 1\n        index += len(substring)\n    return count\n```\n\nThe function starts by initializing a variable `count` to 0 and an index `index` to 0. It then enters a loop that continues as long as the index is less than the length of the input string.\nInside the loop, the function uses the `find` method to search for the next occurrence of the substring starting from the current index. If the substring is not found, the function returns -1 and exits the loop.\nIf the substring is found, the function increments the `count` variable and moves the index forward by the length of the substring. This ensures that the next search starts after the last occurrence of the substring was found.\nFinally, the function returns the `count` variable, which represents the number of times the substring was found in the original string.\nHere are some examples of how to use the `how_many_times` function:\n```scss\n>>> how_many_times('', 'a')\n0\n>>> how_many_times('aaa', 'a')\n3\n>>> how_many_times('aaaa', 'aa')\n3\n>>> how_many_times('abcabcabc', 'abc')\n3\n>>> how_many_times('hello world', 'o')\n2\n```"}
{"task_id": "HumanEval/24", "solution": "This function takes an integer `n` as input and returns the largest number that divides `n` evenly and is smaller than `n`. Here's how it works:\n\n1. The function initializes a variable `divisor` to 2, as 2 is the smallest possible divisor of any integer.\n2. The function uses a for loop to iterate through all the divisors of `n` by incrementing `divisor` by 1 at a time.\n3. For each divisor `divisor`, the function checks if `divisor` divides `n` evenly by using the modulo operator `%`. If `divisor` divides `n` evenly, the function returns `divisor`.\n4. If the function reaches the end of the loop without finding a divisor that divides `n` evenly, it returns `n`.\n\nHere's an example of how the function works:\n\n```python\n>>> largest_divisor(15)\n5\n```\n\nIn this example, `15` has the divisors `1`, `3`, `5`, and `15`. The largest divisor that divides `15` evenly and is smaller than `15` is `5`, so the function returns `5`."}
{"task_id": "HumanEval/30", "solution": "Here's one way to implement the `get_positive()` function in Python:\n```python\ndef get_positive(l: list) -> list:\n    return [num for num in l if num > 0]\n```\n\nThis function takes a list `l` as input and returns a new list containing only the positive numbers from the original list. It does this by using a list comprehension to iterate over each number in the input list, and only adding it to the output list if it is greater than 0."}
{"task_id": "HumanEval/36", "solution": "```python\ndef fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 and i % 13 == 0:\n            count += i % 7 == 7\n        elif i % 11 == 0:\n            count += i % 7 == 0\n        elif i % 13 == 0:\n            count += i % 7 == 0\n    return count\n\n\nprint(fizz_buzz(50))  # output: 0\nprint(fizz_buzz(78))  # output: 2\nprint(fizz_buzz(79))  # output: 3\n```"}
{"task_id": "HumanEval/42", "solution": "Here's one way to implement the `incr_list` function using a list comprehension:\n```python\ndef incr_list(l: list):\n    return [x + 1 for x in l]\n```\n\nThis function creates a new list by iterating over each element in the input list `l`, and incrementing it by 1 using the expression `x + 1`. The new value is then added to the new list using a list comprehension.\nYou can test the function using the following code:\n```python\nprint(incr_list([1, 2, 3]))  # Output: [2, 3, 4]\nprint(incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]))  # Output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n```"}
{"task_id": "HumanEval/48", "solution": "This code defines a function called `is_palindrome` that takes a string `text` as input and returns `True` if the string is a palindrome, and `False` otherwise. A palindrome is a word, phrase, number, or other sequence of characters that reads the same backward as forward. To check if a string is a palindrome, the function compares the characters in the string from both ends towards the middle, and if they are the same, the string is a palindrome. If the characters are different, the string is not a palindrome."}
{"task_id": "HumanEval/54", "solution": "```python\ndef same_chars(s0: str, s1: str) -> bool:\n    return len(s0) == len(s1) and s0.lower() == s1.lower()\n```"}
{"task_id": "HumanEval/60", "solution": "This is a Python function that takes an integer as input and returns the sum of all numbers from 1 to n. Here's how it works:\n\n- First, the function initializes a variable called `total` to 0, which will be used to accumulate the sum of the numbers.\n- Then, it uses a `for` loop to iterate over the numbers from 1 to n (inclusive).\n- For each number in the range, the function adds it to the `total` variable.\n- Finally, the function returns the `total` variable.\n\nHere are some examples of how you can use this function:\n\n```\n>>> sum_to_n(30)\n465\n>>> sum_to_n(100)\n5050\n>>> sum_to_n(5)\n15\n>>> sum_to_n(10)\n55\n>>> sum_to_n(1)\n1\n```\n\nIn the first example, the function adds up all the numbers from 1 to 30 (inclusive), which gives a total of 465.\nIn the second example, the function adds up all the numbers from 1 to 100 (inclusive), which gives a total of 5050.\nIn the third example, the function adds up the numbers 1, 2, 3, 4, and 5, which gives a total of 15.\nIn the fourth example, the function adds up the numbers 1, 2, 3, 4, 5, and 6, which gives a total of 15.\nIn the fifth example, the function adds up the number 1, which gives a total of 1."}
{"task_id": "HumanEval/66", "solution": "Here's one way to write the `digitSum` function in Python:\n```python\ndef digitSum(s):\n    return sum(ord(c) for c in s if c.isupper())\n```\n\nHere's how this function works:\n\n  1. The `ord` function takes a character and returns its ASCII code.\n  2. The `isupper` method returns `True` if the character is in uppercase, and `False` otherwise.\n  3. The `sum` function takes an iterable of numbers and returns their sum.\n\nSo the `digitSum` function iterates over each character in the input string `s`, checks if it's an uppercase character using the `isupper` method, and if it is, adds its ASCII code to the `sum`. Finally, it returns the sum of all the uppercase ASCII codes in the input string."}
{"task_id": "HumanEval/72", "solution": "Here's an implementation of the `will_it_fly` function:\n```python\ndef will_it_fly(q, w):\n    # Check if the list is balanced\n    if q == q[::-1]:\n        # Check if the sum of the list is less than or equal to the maximum possible weight\n        return sum(q) <= w\n    else:\n        return False\n```\n\nThe function first checks if the input list `q` is a palindrome by comparing it to its reverse using the slicing syntax `q[::-1]`. If `q` is a palindrome, the function then checks if the sum of its elements is less than or equal to the maximum possible weight `w` using the `sum` function. If `q` is not a palindrome or its sum is greater than `w`, the function returns `False`. Otherwise, the function returns `True`."}
{"task_id": "HumanEval/78", "solution": "```python\ndef hex_key(num):\n    num = num.upper()\n    count = 0\n    for i in num:\n        if i in ['2','3','5','7','B','D']:\n            count += 1\n    return count\n```"}
{"task_id": "HumanEval/84", "solution": "```python\nclass Solution:\n     def sumOfDigits(self, N):\n         \"\"\"\n         :type N: int\n         :rtype: str\n         \"\"\"\n         s = bin(N)[2:]\n         res = 0\n         for i in s:\n             res += int(i)\n         return str(res)\n```"}
{"task_id": "HumanEval/90", "solution": "```python\ndef next_smallest(lst):\n    # Initialize second smallest element as the first element\n    second_smallest = lst[0]\n    \n    # Iterate over the list starting from the second element\n    for num in lst[1:]:\n        # If the current element is smaller than the second smallest element\n        if num < second_smallest:\n            # Update the second smallest element\n            second_smallest = num\n            \n    # Return the second smallest element\n    return second_smallest\n```"}
{"task_id": "HumanEval/96", "solution": "```python\nimport math\ndef count_up_to(n):\n    prime_numbers = []\n    for i in range(2, int(n**0.5)+1):\n        if all(i % p != 0 for p in prime_numbers):\n            prime_numbers.append(i)\n    return prime_numbers[:n]\n```"}
{"task_id": "HumanEval/102", "solution": "Here's a Python function that implements the problem statement:\n\n```python\ndef choose_num(x, y):\n    num = x\n    while num <= y:\n        if num % 2 == 0:\n            return num\n        num += 1\n    return -1\n```\n\nThe function starts by initializing a variable `num` equal to `x`. It then enters a loop that continues as long as `num` is less than or equal to `y`. Inside the loop, the function checks if `num` is even by checking if `num % 2 == 0`. If `num` is even, the function returns `num`. Otherwise, the function increments `num` by 1 and continues the loop. If the loop completes without finding an even number in the range `[x, y]`, the function returns -1.\n\nHere are some examples of using the function:\n\n```python\nprint(choose_num(12, 15))  # Output: 14\nprint(choose_num(13, 12))  # Output: -1\nprint(choose_num(10, 20))  # Output: 12\nprint(choose_num(20, 20))  # Output: 20\n```"}
{"task_id": "HumanEval/108", "solution": "```python\ndef count_nums(arr):\n    count = 0\n    for num in arr:\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum > 0:\n            count += 1\n    return count\n```"}
{"task_id": "HumanEval/114", "solution": "```python\nclass Solution:\n    def minSubArraySum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        res = float('inf')\n        prefix = 0\n        for num in nums:\n            prefix += num\n            res = min(res , prefix)\n        return res\n```"}
{"task_id": "HumanEval/120", "solution": "```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        if not nums:\n            return []\n        return sorted(nums, reverse=True)[:k]\n```"}
{"task_id": "HumanEval/126", "solution": "Here is a possible solution:\n```python\ndef is_sorted(lst):\n    if len(lst) <= 1:\n        return True\n    else:\n        for i in range(len(lst) - 1):\n            if lst[i] > lst[i + 1]:\n                return False\n        return True\n```"}
{"task_id": "HumanEval/132", "solution": "Here's one way to implement the function:\n\n```python\ndef is_nested(string):\n    stack = []\n    for bracket in string:\n        if bracket == \"[\":\n            stack.append(bracket)\n        elif bracket == \"]\":\n            if not stack:\n                return False\n            top_bracket = stack.pop()\n            if top_bracket != bracket:\n                return False\n    return not stack\n```\n\nThe function uses a stack to keep track of the opening brackets it encounters. For each bracket in the input string, it checks whether it is an opening bracket or a closing bracket. If it is an opening bracket, it is pushed onto the stack. If it is a closing bracket, it is popped off the stack and compared to the current opening bracket. If the top of the stack is not the same as the closing bracket, the function returns False, indicating that there is an unmatched opening bracket. If the stack is empty at the end of the loop, the function returns True, indicating that there is a valid sequence of nested brackets in the input string."}
{"task_id": "HumanEval/138", "solution": "One way to solve this problem is to check if there exist four positive even numbers that add up to n. We can start by checking if n is even, since if it isn't, then we can't use it as the sum of four positive even numbers. If n is even, then we can check if it can be written as the sum of four distinct positive even numbers. We can use a nested loop to generate all possible combinations of four positive even numbers and check if their sum is equal to n. If we find such a combination, then we can return True. If we don't find any combination that works, then we can return False.\nHere's the Python code to implement this solution:\n```python\ndef is_equal_to_sum_even(n):\n    if n % 2 != 0:\n        return False\n    for i in range(2, int(n/2)+1):\n        for j in range(i, int(n/2)+1):\n            for k in range(j, int(n/2)+1):\n                if k > i:\n                    for l in range(k, n):\n                        if l % 2 == 0:\n                            if i + j + k + l == n:\n                                return True\n    return False\n```\n\nWe can test this function with some examples:\n```python\nprint(is_equal_to_sum_even(4))  # False\nprint(is_equal_to_sum_even(6))  # False\nprint(is_equal_to_sum_even(8))  # True\nprint(is_equal_to_sum_even(10)) # False\nprint(is_equal_to_sum_even(12)) # False\nprint(is_equal_to_sum_even(14)) # True\n```\n\nAs we can see, the function correctly identifies whether a given number can be written as the sum of exactly four positive even numbers or not."}
{"task_id": "HumanEval/144", "solution": "Here's a Python function that uses the `fractions` module to simplify the expression `x * n` and returns `True` if it evaluates to an integer, and `False` otherwise:\n\n```python\nfrom fractions import Fraction\n\ndef simplify(x, n):\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    result = int(x_num * n_num / x_den * n_den)\n    return result == x_num * n_num\n```\n\nHere's how the function works:\n\n1. It first splits the fraction strings `x` and `n` into their numerator and denominator using the `split()` method and `map()` function, which converts each string element to an integer using the `int()` function.\n2. It then calculates the result of `x * n` by multiplying the numerator and denominator of `x` by the numerator and denominator of `n`, respectively, and dividing the result by the product of the denominators. This is done using the `Fraction` class from the `fractions` module.\n3. The function then checks if the result of `x * n` is equal to the product of the numerators of `x` and `n` using the `==` operator.\n\nHere are some examples of how to use the `simplify()` function:\n\n```python\nprint(simplify(\"1/5\", \"5/1\"))  # True\nprint(simplify(\"1/6\", \"2/1\"))  # False\nprint(simplify(\"7/10\", \"10/2\"))  # False\n```"}
{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n    if n % 2 == 0:\n        return y\n    else:\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return y\n        return x"}
{"task_id": "HumanEval/156", "solution": "```python\nclass Solution:\n    def intToMiniRoman(self, num: int) -> str:\n        int_to_mini_roman_map = {\n            1000: 'm',\n            900: 'cm',\n            500: 'd',\n            400: 'cd',\n            100: 'c',\n            90: 'xc',\n            50: 'l',\n            40: 'xl',\n            10: 'x',\n            9: 'ix',\n            5: 'v',\n            4: 'iv',\n            1: 'i'\n        }\n        \n        roman_numeral = ''\n        for value, symbol in int_to_mini_roman_map.items():\n            while num >= value:\n                num -= value\n                roman_numeral += symbol\n        return roman_numeral.lower()\n```"}
{"task_id": "HumanEval/162", "solution": "import hashlib\n\ndef string_to_md5(text):\n    if not text: return None\n\n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    return md5_hash"}
